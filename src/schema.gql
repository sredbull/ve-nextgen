# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type User {
  id: Float!
  provider: String!
  providerId: String!
  username: String!
  name: String!
  created_at: DateTime!
  updated_at: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type meta {
  charset: String!
  description: String!
  noindex: Boolean!
  nofollow: Boolean!
  robots: String!
  viewport: String!
}

type head {
  title: String!
  meta: meta!
}

type page {
  lang: String!
  head: head!
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

type PageDeleteResponse {
  lang: String
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

type pageEdge {
  """The node containing the page"""
  node: page!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

type PageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor

  """The cursor of the last returned record."""
  endCursor: ConnectionCursor
}

type PageConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [pageEdge!]!
}

type pageAggregateGroupBy {
  id: ID
}

type pageCountAggregate {
  id: Int
}

type pageSumAggregate {
  id: Float
}

type pageAvgAggregate {
  id: Float
}

type pageMinAggregate {
  id: ID
}

type pageMaxAggregate {
  id: ID
}

type HeadDeleteResponse {
  title: String
}

type headEdge {
  """The node containing the head"""
  node: head!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type HeadConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [headEdge!]!
}

type headAggregateGroupBy {
  id: ID
  title: String
}

type headCountAggregate {
  id: Int
  title: Int
}

type headSumAggregate {
  id: Float
}

type headAvgAggregate {
  id: Float
}

type headMinAggregate {
  id: ID
  title: String
}

type headMaxAggregate {
  id: ID
  title: String
}

type MetaDeleteResponse {
  charset: String
  description: String
  noindex: Boolean
  nofollow: Boolean
  robots: String
  viewport: String
}

type metaEdge {
  """The node containing the meta"""
  node: meta!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type MetaConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [metaEdge!]!
}

type metaAggregateGroupBy {
  id: ID
}

type metaCountAggregate {
  id: Int
}

type metaSumAggregate {
  id: Float
}

type metaAvgAggregate {
  id: Float
}

type metaMinAggregate {
  id: ID
}

type metaMaxAggregate {
  id: ID
}

type Query {
  users: [User!]!
  whoAmI: User!
  page(
    """The id of the record to find."""
    id: ID!
  ): page
  pages(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: pageFilter = {}

    """Specify to sort results."""
    sorting: [pageSort!] = []
  ): PageConnection!
  head(
    """The id of the record to find."""
    id: ID!
  ): head
  heads(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: headFilter = {}

    """Specify to sort results."""
    sorting: [headSort!] = []
  ): HeadConnection!
  meta(
    """The id of the record to find."""
    id: ID!
  ): meta
  metas(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: metaFilter = {}

    """Specify to sort results."""
    sorting: [metaSort!] = []
  ): MetaConnection!
}

input CursorPaging {
  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

input pageFilter {
  and: [pageFilter!]
  or: [pageFilter!]
  id: IDFilterComparison
}

input IDFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ID
  neq: ID
  gt: ID
  gte: ID
  lt: ID
  lte: ID
  like: ID
  notLike: ID
  iLike: ID
  notILike: ID
  in: [ID!]
  notIn: [ID!]
}

input pageSort {
  field: pageSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum pageSortFields {
  id
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input headFilter {
  and: [headFilter!]
  or: [headFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
}

input StringFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: String
  neq: String
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  notLike: String
  iLike: String
  notILike: String
  in: [String!]
  notIn: [String!]
}

input headSort {
  field: headSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum headSortFields {
  id
  title
}

input metaFilter {
  and: [metaFilter!]
  or: [metaFilter!]
  id: IDFilterComparison
}

input metaSort {
  field: metaSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum metaSortFields {
  id
}

type Mutation {
  setHeadOnPage(input: SetHeadOnPageInput!): page!
  createOnePage(input: CreateOnePageInput!): page!
  createManyPages(input: CreateManyPagesInput!): [page!]!
  updateOnePage(input: UpdateOnePageInput!): page!
  updateManyPages(input: UpdateManyPagesInput!): UpdateManyResponse!
  deleteOnePage(input: DeleteOnePageInput!): PageDeleteResponse!
  deleteManyPages(input: DeleteManyPagesInput!): DeleteManyResponse!
  setMetaOnHead(input: SetMetaOnHeadInput!): head!
  createOneHead(input: CreateOneHeadInput!): head!
  createManyHeads(input: CreateManyHeadsInput!): [head!]!
  updateOneHead(input: UpdateOneHeadInput!): head!
  updateManyHeads(input: UpdateManyHeadsInput!): UpdateManyResponse!
  deleteOneHead(input: DeleteOneHeadInput!): HeadDeleteResponse!
  deleteManyHeads(input: DeleteManyHeadsInput!): DeleteManyResponse!
  createOneMeta(input: CreateOneMetaInput!): meta!
  createManyMetas(input: CreateManyMetasInput!): [meta!]!
  updateOneMeta(input: UpdateOneMetaInput!): meta!
  updateManyMetas(input: UpdateManyMetasInput!): UpdateManyResponse!
  deleteOneMeta(input: DeleteOneMetaInput!): MetaDeleteResponse!
  deleteManyMetas(input: DeleteManyMetasInput!): DeleteManyResponse!
}

input SetHeadOnPageInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input CreateOnePageInput {
  """The record to create"""
  page: CreatePage!
}

input CreatePage {
  lang: String
}

input CreateManyPagesInput {
  """Array of records to create"""
  pages: [CreatePage!]!
}

input UpdateOnePageInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePage!
}

input UpdatePage {
  lang: String
}

input UpdateManyPagesInput {
  """Filter used to find fields to update"""
  filter: pageUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdatePage!
}

input pageUpdateFilter {
  and: [pageUpdateFilter!]
  or: [pageUpdateFilter!]
  id: IDFilterComparison
}

input DeleteOnePageInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteManyPagesInput {
  """Filter to find records to delete"""
  filter: pageDeleteFilter!
}

input pageDeleteFilter {
  and: [pageDeleteFilter!]
  or: [pageDeleteFilter!]
  id: IDFilterComparison
}

input SetMetaOnHeadInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input CreateOneHeadInput {
  """The record to create"""
  head: CreateHead!
}

input CreateHead {
  title: String
}

input CreateManyHeadsInput {
  """Array of records to create"""
  heads: [CreateHead!]!
}

input UpdateOneHeadInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateHead!
}

input UpdateHead {
  title: String
}

input UpdateManyHeadsInput {
  """Filter used to find fields to update"""
  filter: headUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateHead!
}

input headUpdateFilter {
  and: [headUpdateFilter!]
  or: [headUpdateFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
}

input DeleteOneHeadInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteManyHeadsInput {
  """Filter to find records to delete"""
  filter: headDeleteFilter!
}

input headDeleteFilter {
  and: [headDeleteFilter!]
  or: [headDeleteFilter!]
  id: IDFilterComparison
  title: StringFieldComparison
}

input CreateOneMetaInput {
  """The record to create"""
  meta: CreateMeta!
}

input CreateMeta {
  charset: String
  description: String
  noindex: Boolean
  nofollow: Boolean
  robots: String
  viewport: String
}

input CreateManyMetasInput {
  """Array of records to create"""
  metas: [CreateMeta!]!
}

input UpdateOneMetaInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateMeta!
}

input UpdateMeta {
  charset: String
  description: String
  noindex: Boolean
  nofollow: Boolean
  robots: String
  viewport: String
}

input UpdateManyMetasInput {
  """Filter used to find fields to update"""
  filter: metaUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateMeta!
}

input metaUpdateFilter {
  and: [metaUpdateFilter!]
  or: [metaUpdateFilter!]
  id: IDFilterComparison
}

input DeleteOneMetaInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteManyMetasInput {
  """Filter to find records to delete"""
  filter: metaDeleteFilter!
}

input metaDeleteFilter {
  and: [metaDeleteFilter!]
  or: [metaDeleteFilter!]
  id: IDFilterComparison
}